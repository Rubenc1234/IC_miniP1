\documentclass[a4paper, 11pt, portuguese]{article}

% --- PACOTES ESSENCIAIS ---
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % Codificação do ficheiro
\usepackage{babel}          % Suporte para Português
\usepackage{amsmath}        % Fórmulas matemáticas avançadas
\usepackage{amssymb}        % Símbolos matemáticos
\usepackage{graphicx}       % Inclusão de imagens
\usepackage[
    colorlinks=true,        % Links coloridos em vez de caixas
    linkcolor=blue,         % Cor dos links internos
    citecolor=blue,         % Cor das citações (se usar bib)
    urlcolor=blue           % Cor dos URLs
]{hyperref}                 % Links clicáveis (URLs, referências)
\usepackage{geometry}       % Configuração das margens
\usepackage{booktabs}       % Tabelas com melhor aspeto
\usepackage{listings}       % Blocos de código formatados
\usepackage{xcolor}         % Cores (usado nos listings)
\usepackage{float}          % Controlo mais fino da posição de floats (figuras, tabelas)

% --- CONFIGURAÇÕES ---

% Margens da página
\geometry{
 a4paper,
 margin=2.5cm, % Margem de 2.5cm em todos os lados
}

% Estilo para blocos de código C++
\definecolor{codegray}{rgb}{0.5,0.5,0.5} % Cor para comentários
\definecolor{codeblue}{rgb}{0,0,0.6}    % Cor para palavras-chave
\definecolor{codegreen}{rgb}{0,0.6,0}  % Cor para strings
\lstdefinestyle{cppstyle}{
    language=C++,
    basicstyle=\ttfamily\footnotesize, % Fonte monoespaçada pequena
    commentstyle=\color{codegray}\itshape, % Comentários em cinza itálico
    keywordstyle=\color{codeblue}\bfseries, % Palavras-chave a azul negrito
    stringstyle=\color{codegreen},    % Strings a verde
    numberstyle=\tiny\color{codegray}, % Números de linha pequenos e cinza
    breaklines=true,                  % Quebra de linhas longas
    frame=single,                     % Caixa à volta do código
    captionpos=b,                     % Legenda em baixo
    showstringspaces=false,           % Não mostrar espaços em strings de forma especial
    tabsize=4,                        % Tamanho da tabulação
    numbers=left,                     % Números de linha à esquerda
    stepnumber=1,                     % Numerar todas as linhas
    numbersep=5pt,                    % Espaço entre números e código
    backgroundcolor=\color{white},    % Fundo branco
    % --- Tratamento de caracteres PT ---
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
             {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
             {â}{{\^a}}1 {ê}{{\^e}}1 {ô}{{\^o}}1
             {Â}{{\^A}}1 {Ê}{{\^E}}1 {Ô}{{\^O}}1
             {ã}{{\~a}}1 {õ}{{\~o}}1
             {Ã}{{\~A}}1 {Õ}{{\~O}}1
             {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1,
}
\lstset{style=cppstyle} % Define o estilo C++ como padrão para listings

% Configuração do idioma principal do documento
\selectlanguage{portuguese}

% --- INFORMAÇÕES DO DOCUMENTO ---
\title{
    \includegraphics[width=0.4\textwidth]{imagens/ua.pdf} \\ \vspace{1.5cm}
    \textbf{Relatório do Trabalho Laboratorial nº 2} \\
    \large Informação e Codificação (2025/26)
}
\author{
    \textbf{Pedro Miguel Miranda de Melo} (114208) \\
    \textbf{Rúben Cardeal Costa} (114190) \\
    \textbf{Hugo Marques Dias} (114142) \\
    % Adicionar mais linhas conforme necessário
    \textit{Departamento de Eletrónica, Telecomunicações e Informática (DETI)} \\
    \textit{Universidade de Aveiro}
}
\date{Novembro de 2025}

% --- INÍCIO DO DOCUMENTO ---
\begin{document}

\maketitle
\thispagestyle{empty} % Remove número de página na folha de rosto

\newpage
\tableofcontents % Gera o índice automaticamente
\newpage

% ----------------------------------------------------------------------------------
% SECÇÃO 1: INTRODUÇÃO
% ----------------------------------------------------------------------------------
\section{Introdução}

Este relatório documenta o desenvolvimento e os resultados obtidos no âmbito do Trabalho Laboratorial nº 2 da unidade curricular de Informação e Codificação.

O projeto foca-se em duas áreas principais: a manipulação básica de imagens digitais utilizando a biblioteca OpenCV e a implementação de um sistema de codificação entrópica (Codificação Golomb) aplicado à compressão sem perdas (\textit{lossless}) de sinais de áudio e imagem.

O código-fonte completo do projeto está disponível publicamente no seguinte repositório GitHub: \url{https://github.com/Rubenc1234/IC_miniP1/tree/main/Project2}.

% ----------------------------------------------------------------------------------
% SECÇÃO 2: PARTE I - MANIPULAÇÃO DE IMAGENS COM OPENCV
% ----------------------------------------------------------------------------------
\section{Parte I: Manipulação Básica de Imagens com OpenCV}

A primeira parte do trabalho consistiu na familiarização com a biblioteca OpenCV através da implementação de programas para realizar operações fundamentais em imagens digitais, manipulando diretamente os seus píxeis.

\subsection{Programa \texttt{extract\_channel}}

Este programa tem como objetivo extrair um canal de cor específico (Azul, Verde ou Vermelho) de uma imagem de entrada, gerando uma imagem de saída em tons de cinza correspondente a esse canal.

\subsubsection{Funcionalidade e Utilização}
O programa lê uma imagem a cores, que é representada internamente em formato BGR pelo OpenCV. 
Em seguida, é criada uma nova imagem monocromática (\texttt{CV\_8UC1}) com as mesmas dimensões da original. 
O processamento é feito píxel a píxel: para cada píxel, o valor do canal especificado pelo utilizador (0 para Azul, 1 para Verde, 2 para Vermelho) é copiado para a posição correspondente na imagem de saída. 
A leitura e escrita dos valores dos píxeis é realizada utilizando o método \texttt{Mat::at<>()}.

A sintaxe de utilização é a seguinte:
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do extract\_channel]
./bin/extract_channel <imagem_entrada> <imagem_saida> <numero_canal>
\end{lstlisting}
Onde \texttt{numero\_canal} deve ser 0, 1 ou 2. O formato da imagem de saída deve ser um que suporte imagens monocromáticas, como \texttt{.pgm} ou \texttt{.png}.

\paragraph{Exemplo de Teste:}
Para extrair os canais Azul (0), Verde (1) e Vermelho (2) da imagem \texttt{airplane.ppm}:
\begin{lstlisting}[language=bash]
./bin/extract_channel img/airplane.ppm imagens/airplane_extract_0.png 0
./bin/extract_channel img/airplane.ppm imagens/airplane_extract_1.png 1
./bin/extract_channel img/airplane.ppm imagens/airplane_extract_2.png 2
\end{lstlisting}

A Figura~\ref{fig:canais_extraidos} mostra o resultado da extração dos três canais de cor.

\begin{figure}[htbp]
\centering
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane.png} % Assumindo que tem uma versão png da original
    \caption*{Imagem Original (airplane)}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane_extract_0.png}
    \caption*{Canal Azul (0)}
\end{minipage}
\vspace{0.5cm} % Espaço vertical entre as linhas de imagens
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane_extract_1.png}
    \caption*{Canal Verde (1)}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane_extract_2.png}
    \caption*{Canal Vermelho (2)}
\end{minipage}
\caption{Extração dos canais B, G, R da imagem original.}
\label{fig:canais_extraidos}
\end{figure}

\subsection{Programa \texttt{image\_operations}}

Este programa engloba um conjunto de operações geométricas e de intensidade sobre imagens, implementadas através da manipulação direta dos píxeis, sem recurso a funções específicas do OpenCV para essas transformações. Foram criados programas separados para cada operação para maior clareza.

\subsubsection{Negativo da Imagem (\texttt{image\_negative})}
Esta operação inverte os valores de intensidade de cada canal de cor de uma imagem. 
Para imagens com 8 bits por canal, o valor de cada píxel no negativo, denotado por $P'_{\text{cor}}$, é obtido subtraindo o valor original $P_{\text{cor}}$ de 255, ou seja, 
$P'_{\text{cor}} = 255 - P_{\text{cor}}$. 
Esta operação é realizada de forma independente em cada um dos canais B, G e R.


\vspace{0.3cm}
\noindent\textbf{Utilização e Exemplo:}
\medskip
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do image\_negative]
./bin/image_negative <imagem_entrada> <imagem_saida> [view]
\end{lstlisting}
\begin{lstlisting}[language=bash]
./bin/image_negative img/airplane.ppm imagens/airplane_neg.png
\end{lstlisting}
O resultado é apresentado na Figura~\ref{fig:negativo}.

\begin{figure}[htbp]
\centering
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane.png}
    \caption*{Imagem Original}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/airplane_neg.png}
    \caption*{Imagem Negativa}
\end{minipage}
\caption{Resultado da operação de negativo.}
\label{fig:negativo}
\end{figure}

\subsubsection{Espelhamento da Imagem (\texttt{image\_mirror})}
Esta funcionalidade permite criar uma versão espelhada da imagem, invertendo a posição dos píxeis. 
No espelhamento horizontal, cada linha da imagem é invertida, de modo que os píxeis à esquerda passam para a direita e vice-versa. 
No espelhamento vertical, cada coluna da imagem é invertida, de forma que os píxeis do topo passam para a parte inferior e os do fundo passam para o topo.
\begin{itemize}
    \item \textbf{Espelhamento Horizontal (h):} O píxel $(r, c)$ recebe o valor do píxel $(r, \text{largura} - 1 - c)$.
    \item \textbf{Espelhamento Vertical (v):} O píxel $(r, c)$ recebe o valor do píxel $(\text{altura} - 1 - r, c)$.
\end{itemize}

\vspace{0.3cm}
\noindent\textbf{Utilização e Exemplo:}
\medskip
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do image\_mirror]
./bin/image_mirror <imagem_entrada> <imagem_saida> <h | v> [view]
\end{lstlisting}
\begin{lstlisting}[language=bash]
./bin/image_mirror img/airplane.ppm imagens/airplane_mirror_h.png h
./bin/image_mirror img/airplane.ppm imagens/airplane_mirror_v.png v
\end{lstlisting}
Os resultados são apresentados na Figura~\ref{fig:espelhamento}.

\begin{figure}[htbp]
\centering
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane.png}
    \caption*{Original}
\end{minipage}
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane_mirror_h.png}
    \caption*{Espelhada Horizontalmente}
\end{minipage}
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane_mirror_v.png}
    \caption*{Espelhada Verticalmente}
\end{minipage}
\caption{Resultados da operação de espelhamento.}
\label{fig:espelhamento}
\end{figure}

\subsubsection{Rotação da Imagem (\texttt{image\_rotate})}
Esta funcionalidade permite rotacionar a imagem por qualquer ângulo que seja múltiplo de 90 graus, podendo ser positivo, negativo ou zero. 
O programa normaliza o ângulo fornecido para um valor equivalente em $\{0, 90, 180, 270\}$ graus no sentido horário e, em seguida, calcula a nova posição de cada píxel com base na sua posição original. 
Nos casos de rotação de 90 ou 270 graus, as dimensões da imagem são invertidas, ou seja, a largura passa a ser altura e a altura passa a ser largura.

\vspace{0.3cm}
\noindent\textbf{Utilização e Exemplo:}
\medskip
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do image\_rotate]
./bin/image_rotate <imagem_entrada> <imagem_saida> <angulo>
\end{lstlisting}
\begin{lstlisting}[language=bash]
./bin/image_rotate img/airplane.ppm imagens/airplane_rotated90.png 90
./bin/image_rotate img/airplane.ppm imagens/airplane_rotated180.png 180 %
./bin/image_rotate img/airplane.ppm imagens/airplane_rotated270.png 270 %
\end{lstlisting}
A Figura~\ref{fig:rotacao} ilustra a rotação de 90 graus.

\begin{figure}[htbp]
\centering
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/airplane.png} % Ajustar tamanho se necessário
    \caption*{Imagem Original}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/airplane_rotated90.png}
    \caption*{Rotação 90° Horário}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/airplane_rotated180.png}
    \caption*{Rotação 180° Horário}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/airplane_rotated270.png}
    \caption*{Rotação 270° Horário}
\end{minipage}
\caption{Resultado da operação de rotação.}
\label{fig:rotacao}
\end{figure}

\subsubsection{Ajuste de Intensidade (\texttt{image\_intensity})}
Esta funcionalidade permite aumentar ou diminuir o brilho geral da imagem. 
O programa recebe um valor percentual no intervalo $[-100, 100]$ e converte esse valor em um ajuste aditivo $A$, calculado como $A = \text{round}(\text{percentagem} \times 2.55)$. 
Em seguida, este ajuste é somado a cada canal de cor (B, G e R) de cada píxel da imagem. 
Para garantir que os valores finais permaneçam no intervalo válido $[0, 255]$, utiliza-se a função \texttt{saturate\_cast<uchar>}.


\vspace{0.3cm}
\noindent\textbf{Utilização e Exemplo:}
\medskip
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do image\_intensity]
./bin/image_intensity <imagem_entrada> <imagem_saida> <percentagem_ajuste>
\end{lstlisting}
\begin{lstlisting}[language=bash]
./bin/image_intensity img/airplane.ppm imagens/airplane_brighter_50.png 50
./bin/image_intensity img/airplane.ppm imagens/airplane_darker_-50.png -50
\end{lstlisting}
A Figura~\ref{fig:intensidade} mostra os resultados para aumento e diminuição de 50\%.

\begin{figure}[htbp]
\centering
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane.png}
    \caption*{Original (0\%)}
\end{minipage}
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane_brighter_50.png}
    \caption*{Brilho +50\%}
\end{minipage}
\hfill
\begin{minipage}{0.32\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagens/airplane_darker_-50.png}
    \caption*{Brilho -50\%}
\end{minipage}
\caption{Resultados da operação de ajuste de intensidade.}
\label{fig:intensidade}
\end{figure}

% ----------------------------------------------------------------------------------
% SECÇÃO 3: PARTE II - CLASSE DE CODIFICAÇÃO GOLOMB
% ----------------------------------------------------------------------------------
\section{Parte II: Classe de Codificação Golomb}

Nesta parte, implementou-se uma classe C++ para a codificação Golomb, uma técnica de compressão de dados eficiente, especialmente adequada para fontes com distribuição geométrica. 
A classe foi projetada para servir como base para os codecs \textit{lossless} nas partes seguintes.

\subsection{Princípio de Codificação Golomb}

A codificação Golomb é uma família de códigos que depende de um parâmetro inteiro $m > 0$. A implementação segue a teoria descrita nos documentos de apoio:

\begin{enumerate}
    \item Um inteiro não-negativo $i$ é dividido em duas partes: um quociente $q$ e um resto $r$, calculados como $q = \lfloor i/m \rfloor$ e $r = i - q m$.
    \item O quociente $q$ é codificado em código unário, ou seja, uma sequência de $q$ bits '1' seguida de um bit '0'.
    \item O resto $r$ é codificado usando um código binário.
\end{enumerate}

\subsubsection{A forma como o resto $r$ é codificado depende do valor de $m$:}

\paragraph{Caso 1: $m$ é uma potência de 2 (Golomb-Rice)}
Se $m = 2^b$, o resto $r$ (que estará no intervalo $[0, m-1]$) é simplesmente codificado usando a sua representação binária com $b = \log_2(m)$ bits.

\paragraph{Caso 2: $m$ não é uma potência de 2 (Código Binário Truncado)}
Se $m$ não é uma potência de 2, a codificação do resto é otimizada usando a regra do "truncated binary code":
\begin{enumerate}
    \item Calcula-se $b = \lceil \log_2 m \rceil$.
    \item Calcula-se o valor de "corte" $t = 2^b - m$.
    \item Se $r < t$, o resto é codificado usando $b-1$ bits.
    \item Se $r \ge t$, o resto é codificado usando $b$ bits, representando o valor $r + t$.
\end{enumerate}
A nossa classe deteta automaticamente se $m$ é uma potência de 2 e aplica a regra de codificação do resto apropriada (Golomb-Rice ou genérica).

\subsection{Tratamento de Números Negativos}
O enunciado pedia o suporte para números negativos usando duas estratégias distintas. Estas são selecionadas no construtor da classe.

\begin{itemize}
    \item \textbf{1. Sinal e Magnitude (\texttt{SIGN\_MAGNITUDE}):} Esta abordagem utiliza um bit de sinal extra. No nosso caso, '0' para positivo/zero e '1' para negativo. Este bit é escrito no início do \textit{codeword}. O codificador Golomb é depois aplicado ao valor absoluto (magnitude) do número.
    
    \item \textbf{2. Intercalamento (\texttt{INTERLEAVING}):} Esta abordagem mapeia valores positivos e negativos para inteiros não-negativos antes da codificação. A regra de mapeamento utilizada foi:
        $$ i = \begin{cases} 2n & \text{se } n \ge 0 \\ 2|n| - 1 & \text{se } n < 0 \end{cases} $$
    Isto gera a sequência $0 \to 0, -1 \to 1, 1 \to 2, -2 \to 3, \dots$. O descodificador simplesmente inverte este mapeamento após a descodificação Golomb.
\end{itemize}

\subsection{Interface da Classe Implementada}

Foi implementada uma classe \texttt{Golomb} com a seguinte interface pública:

\begin{lstlisting}[language=C++, caption={Interface C++ da classe Golomb (Golomb.h)}]
// Enum para selecionar o modo de tratamento de negativos
enum class SignHandling {
    SIGN_MAGNITUDE,
    INTERLEAVING
};

class Golomb {
public:
    // Construtor que recebe o parâmetro 'm' e o modo
    Golomb(int m_param, SignHandling mode_param);

    // Codifica um inteiro numa string de '0's e '1's 
    std::string encode(int n);

    // Descodifica bits de uma string, atualizando o índice 
    int decode(const std::string& bits, size_t& index);

private:
    // Métodos privados para o mapeamento de negativos e
    // codificação/descodificação de inteiros não-negativos.
    // ...
};
\end{lstlisting}

A classe foi testada com os valores de exemplo fornecidos nos documentos de apoio (como o Exemplo 5.7, para $m=5$ ) e com os testes de exemplo desenvolvidos (incluindo $m=4$ para Golomb-Rice), verificando-se a correção de ambas as estratégias de tratamento de negativos e da lógica de codificação genérica e Golomb-Rice.


% ----------------------------------------------------------------------------------
% SECÇÃO 4: PARTE III - CODEC ÁUDIO LOSSLESS
% ----------------------------------------------------------------------------------
\section{Parte III: Codec Áudio Lossless}

Nesta secção, foi desenvolvido um codec de áudio sem perdas (\textit{lossless}), conforme solicitado na Parte III do enunciado. O objetivo é comprimir ficheiros de áudio (mono e estéreo) aplicando a codificação Golomb (implementada na Parte II) sobre os resíduos de um preditor.

Para maximizar a compressão, o codec implementa uma arquitetura de \texttt{m} adaptativo por bloco, similar à do codec de imagem.

\subsection{Codificador \texttt{audio\_encoder}}

\subsubsection{Algoritmo de Codificação}
O codificador (\texttt{audio\_encoder.cpp}) processa o áudio em blocos, calculando o \texttt{m} ótimo para cada um e escrevendo-o no \textit{bitstream}.

\begin{enumerate}
    \item \textbf{Leitura e Cabeçalho:} O ficheiro WAV é lido para a memória. O codificador escreve um cabeçalho no ficheiro de saída contendo os metadados (\texttt{samplerate}, \texttt{numChannels}, \texttt{numFrames}).
    
    \item \textbf{Processamento por Blocos:} O áudio é processado em blocos (\texttt{blockSize = 4096} tramas). Para cada bloco:
    \begin{itemize}
        \item \textbf{Passagem 1 (do Bloco):} É feita uma passagem interna no bloco para calcular todos os resíduos.
            \begin{itemize}
                \item \textbf{Estéreo (MID/SIDE):} Se \texttt{numChannels == 2}, é aplicada a transformação \textit{lossless} (MID = $\lfloor(L+R)/2\rfloor$, SIDE = $L-R$).
                \item \textbf{Predição (Ordem 1):} É aplicado um preditor temporal de 1ª ordem ($P[n] = x[n-1]$) a cada canal (Mono, ou MID e SIDE). O estado do preditor (e.g., \texttt{mono\_pred}) é mantido entre os blocos.
                \item Os resíduos ($e = x - P$) são guardados em vetores temporários.
            \end{itemize}
        \item \textbf{Cálculo de \texttt{m} Ótimo:} A função \texttt{calculate\_optimal\_m} é chamada para os vetores de resíduos.
        \item \textbf{Escrita de \texttt{m}:} O(s) \texttt{m}'s ótimos (16 bits cada) são escritos no \textit{bitstream}.
        \item \textbf{Passagem 2 (do Bloco):} Os resíduos são codificados com os \texttt{m}'s ótimos e escritos no \textit{bitstream}.
    \end{itemize}
    \item \textbf{Empacotamento de Bits:} A \textit{string} de bits total é empacotada em bytes e escrita no ficheiro de saída.
\end{enumerate}

\subsubsection{Determinação Adaptativa do Parâmetro \texttt{m}}
A chave para a compressão é "sintonizar" o codificador Golomb com os dados. A função \texttt{calculate\_optimal\_m} é usada para encontrar o \texttt{m} ideal para cada bloco de resíduos.

\paragraph{Teoria vs. Prática}
A teoria define \texttt{m} em função de parâmetros estatísticos teóricos ($\alpha$ ou $p=P(x=0)$). Na prática, não conhecemos estes parâmetros, mas podemos medi-los através da média dos nossos dados (os resíduos).

A nossa classe \texttt{Golomb} usa o mapeamento \texttt{INTERLEAVING} para converter os resíduos com sinal em inteiros não-negativos $i$. A teoria de compressão (usada em \textit{standards} como o JPEG-LS) demonstra que o \texttt{m} ótimo pode ser estimado diretamente da média ($\mu$) destes valores $i$ mapeados, usando a aproximação:
$$ m \approx \mu \times \ln(2) $$

\paragraph{Implementação}
A nossa função \texttt{calculate\_optimal\_m} implementa esta lógica:
\begin{enumerate}
    \item Calcula a média (`mean`) dos resíduos após o mapeamento \texttt{INTERLEAVING}.
    \item Estima \texttt{m} usando a fórmula: `m = round(mean * log(2))`.
\end{enumerate}
Isto garante que cada bloco usa o codificador Golomb mais eficiente para os seus resíduos específicos.

\subsubsection{Sintaxe e Exemplos}
O codificador calcula \texttt{m} automaticamente, não sendo um argumento.
\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do audio\_encoder]
./bin/audio_encoder <ficheiro_entrada.wav> <ficheiro_saida.bin>
\end{lstlisting}
\begin{lstlisting}[language=bash, caption=Exemplo de Codificação de Áudio]
./bin/audio_encoder wav/sample.wav wav_out/sample_encoded.glob
\end{lstlisting}

\subsection{Descodificador \texttt{audio\_decoder}}
O descodificador (\texttt{audio\_decoder.cpp}) inverte o processo, lendo o \texttt{m} de cada bloco.

\begin{lstlisting}[language=bash, caption=Sintaxe de Uso do audio\_decoder]
./bin/audio_decoder <ficheiro_entrada.bin> <ficheiro_saida.wav>
\end{lstlisting}
\begin{lstlisting}[language=bash, caption=Exemplo de Descodificação de Áudio]
./bin/audio_decoder wav_out/sample_encoded.glob wav_out/sample_decoded.wav
\end{lstlisting}


\subsubsection{Garantia de Reconstrução Lossless}
Duas decisões de implementação são cruciais para garantir a reconstrução 100\% \textit{lossless} do sinal:
\begin{itemize}
    \item \textbf{Cálculos em 32-bit:} Todos os cálculos de predição e resíduos (incluindo MID/SIDE) são feitos com \texttt{int32\_t}. Isto previne qualquer \textit{integer overflow} que poderia ocorrer ao subtrair amostras de 16 bits (e.g., $30000 - (-30000)$), garantindo a integridade dos resíduos.
    
    \item \textbf{Transformação MID/SIDE Reversível:} A transformação estéreo é implementada de forma a ser 100\% reversível com aritmética inteira. O codificador usa \texttt{side = L - R} e \texttt{mid = R + (side >> 1)}. O descodificador inverte-a com \texttt{R = mid - (side >> 1)} e \texttt{L = R + side}, garantindo que não há erros de arredondamento.
\end{itemize}

\subsection{Análise de Desempenho e Compressão}
O codec foi testado com dois ficheiros de áudio estéreo.

\begin{table}[htbp]
\centering
\caption{Análise de Compressão do Codec Áudio (Preditor Ordem 1, M Adaptativo)}
\label{tab:compressao_audio}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Ficheiro} & \textbf{Original} & \textbf{Comprimido} & \textbf{Taxa de Compressão} \\ \midrule
sample.wav & 2.1 MB & 1.6 MB &  1.31 : 1 \\
sample2.wav & 4.8 MB & 3.1 MB &  1.55 : 1 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\caption{Tempos de Execução do Codec Áudio (ms)}
\label{tab:tempos_audio}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Ficheiro} & \textbf{Codificação (ms)} & \textbf{Descodificação (ms)} \\ \midrule
sample.wav & 105.80 ms & 57.91 ms \\
sample2.wav & 216.66 ms & 113.14 ms \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Análise dos Resultados}
Os testes de verificação com \texttt{wav\_cmp} (demonstrados nos testes executados) confirmaram que o codec é 100\% lossless, com `MSE = 0.0` e `SNR = inf`. A compressão alcançada (1.3:1 a 1.5:1) é modesta. Isto deve-se inteiramente à simplicidade do preditor de 1ª ordem ($P[n] = x[n-1]$). Este preditor é fraco para sinais de áudio complexos, gerando resíduos médios elevados. Consequentemente, o \texttt{m} ótimo calculado por bloco é alto, e a codificação Golomb não consegue ser muito eficiente.


\subsection{Comparação com Codec FLAC}

Para a análise, foi utilizado um ficheiro de áudio estéreo de 12 segundos (2.1 MB). Para validar a eficiência do codec desenvolvido, os resultados foram comparados com o FLAC (\textit{Free Lossless Audio Codec}) configurado com compressão máxima (\texttt{-8}).

\subsubsection{Resultados Comparativos}

\begin{table}[htbp]
\centering
\caption{Comparação de Compressão: O Nosso Codec vs. FLAC (ficheiro \texttt{sample.wav})}
\label{tab:compressao_audio_comparativa}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Codec} & \textbf{Tamanho Final} & \textbf{Taxa de Compressão} & \textbf{Poupança} \\ \midrule
Original (WAV) & 2.1 MB & 1.00 : 1 & 0\% \\
\textbf{O Nosso Codec} & \textbf{1.6 MB} & \textbf{1.31 : 1} & \textbf{23.8\%} \\
FLAC (Nível 8) & 1.5 MB & 1.44 : 1 & 29.6\% \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Discussão}
Os resultados apresentados na Tabela~\ref{tab:compressao_audio_comparativa} são extremamente positivos. O nosso codec, embora académico, atingiu um tamanho de ficheiro (1.6 MB) muito próximo do FLAC (1.5 MB), ficando a uma distância de apenas cerca de 100 kB.

Esta proximidade demonstra a robustez da nossa implementação:
\begin{itemize}
    \item \textbf{Eficiência da Adaptação:} O facto de estarmos tão perto do FLAC, mesmo usando um preditor linear fixo de 1ª ordem ($P[n]=x[n-1]$), prova que a nossa estratégia de adaptação do parâmetro \texttt{m} por bloco (4096 amostras) é altamente eficaz. O codec consegue ajustar-se rapidamente às variações de energia do sinal, maximizando a eficiência do código Golomb.
    \item \textbf{Diferença para o FLAC:} A vantagem residual do FLAC (cerca de 6\% extra de poupança) deve-se ao uso de \textbf{Predição Linear Adaptativa (LPC)}. Enquanto o nosso codec usa um preditor fixo, o FLAC calcula coeficientes de predição ótimos para cada bloco, conseguindo reduzir ainda mais os resíduos em passagens complexas. No entanto, o custo computacional dessa otimização é muito superior ao do nosso método.
\end{itemize}

Em suma, o nosso codec oferece um excelente compromisso, atingindo uma performance competitiva com uma complexidade algorítmica muito inferior à de um codec comercial.
% ----------------------------------------------------------------------------------
% SECÇÃO 5: PARTE IV - CODEC IMAGEM LOSSLESS (GRAYSCALE)
% ----------------------------------------------------------------------------------
\section{Parte IV: Codec Imagem Lossless (Grayscale)}

Aplicando a mesma arquitetura de \texttt{m} adaptativo por bloco, foi desenvolvido um codec \textit{lossless} para imagens em escala de cinza.

\subsection{Arquitetura do Codec (\texttt{image\_encoder} / \texttt{image\_decoder})}

\subsubsection{Algoritmo de Codificação}
O codificador (\texttt{image\_encoder.cpp}) implementa uma lógica adaptativa por blocos de 16x16.

\begin{enumerate}
    \item \textbf{Leitura e Conversão:} A imagem de entrada (PPM) é lida e convertida para escala de cinza usando a função \texttt{readPPMtoGray}.
    \item \textbf{Escrita do Cabeçalho:} Um "magic number" (\texttt{"GOL1"}) é escrito, seguido das dimensões da imagem e \texttt{maxval}.
    \item \textbf{Processamento por Blocos (16x16):} Para cada bloco:
    \begin{itemize}
        \item \textbf{Passagem 1 (Análise):} O codificador calcula os resíduos de predição para o bloco. É usado o preditor MED (Median Edge-Detection), que estima o píxel atual $P(x,y)$ com base nos vizinhos Oeste ($a$), Norte ($b$) e Noroeste ($c$):
        $$
        P(x,y) = \begin{cases} 
        \min(a, b) & \text{se } c \ge \max(a, b) \\
        \max(a, b) & \text{se } c \le \min(a, b) \\
        a + b - c & \text{caso contrário}
        \end{cases}
        $$
        \item \textbf{Cálculo de \texttt{m}:} O \texttt{m} ótimo para os resíduos do bloco é calculado com \texttt{calculate\_optimal\_m}.
        \item \textbf{Escrita de \texttt{m}:} O \texttt{m} ótimo (16 bits) é escrito no \textit{bitstream} do bloco.
        \item \textbf{Passagem 2 (Codificação):} Os resíduos do bloco são codificados com \texttt{Golomb(m\_otimo, INTERLEAVING)} e escritos no \textit{bitstream}.
    \end{itemize}
\end{enumerate}

\subsubsection{Algoritmo de Descodificação}
O descodificador (\texttt{image\_decoder.cpp}) inverte o processo.

\begin{enumerate}
    \item \textbf{Processamento por Blocos:} Itera pela imagem na mesma ordem de blocos.
    \item \textbf{Leitura de \texttt{m}:} No início de cada bloco, lê 16 bits do \textit{bitstream} para obter o \texttt{m} específico desse bloco.
    \item \textbf{Reconstrução:} Itera pelos píxeis do bloco. Calcula o valor de predição $P(x,y)$ usando o mesmo preditor MED sobre os píxeis \textbf{já reconstruídos}.
    \item Descodifica o resíduo $e$ e reconstrói o píxel $\text{píxel} = P(x,y) + e$.
\end{enumerate}

\subsection{Análise de Desempenho e Compressão}

A eficácia do codec foi testada com três imagens de teste.

\begin{table}[htbp]
\centering
\caption{Análise de Compressão do Codec de Imagem}
\label{tab:compressao_imagem}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Imagem} & \textbf{Original (PPM)} & \textbf{Comprimido (GOL)} & \textbf{Taxa de Compressão} \\ \midrule
airplane.ppm & 769 kB & 130 kB & \textbf{5.92 : 1} \\
arial.ppm & 1.1 MB & 262 kB & \textbf{4.20 : 1} \\
bike3.ppm & 2.1 MB & 423 kB & \textbf{4.96 : 1} \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\caption{Tempos de Execução do Codec de Imagem}
\label{tab:tempos_imagem}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Imagem} & \textbf{Codificação (s)} & \textbf{Descodificação (ms)} \\ \midrule
airplane.ppm & 1.05 s & 24.12 ms \\
arial.ppm & 4.73 s & 34.86 ms \\
bike3.ppm & 11.42 s & 60.16 ms \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Análise dos Resultados}
Os resultados demonstram uma eficácia excecional do codec de imagem, com taxas de compressão a rondar 5:1 ou 6:1.

\begin{itemize}
    \item \textbf{Eficácia do Preditor MED:} O sucesso deve-se principalmente ao preditor não-linear MED. Ao contrário do preditor linear simples do áudio, o MED adapta-se às arestas da imagem, gerando resíduos extremamente pequenos (muitas vezes zero) em áreas uniformes.
    \item \textbf{Assimetria de Tempo:} Observa-se uma grande assimetria nos tempos de execução (Tabela~\ref{tab:tempos_imagem}). A descodificação é extremamente rápida (milissegundos) porque é uma operação direta. A codificação é mais lenta (segundos) devido à necessidade de processar cada bloco duas vezes: uma para calcular estatísticas e o \texttt{m} ótimo, e outra para codificar.
\end{itemize}


\subsection{Comparação com Standards de Compressão Lossless}

A eficácia do codec foi testada com três imagens de teste. Para garantir uma comparação justa, as imagens originais foram convertidas para \textit{grayscale} (PGM) antes de serem comprimidas pelos codecs de referência (PNG e FLIF), uma vez que o nosso codec opera apenas sobre um canal de intensidade.

\begin{table}[htbp]
\centering
\caption{Comparação de Compressão: O Nosso Codec vs. Standards (Grayscale)}
\label{tab:compressao_imagem}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Codec} & \textbf{airplane.ppm} & \textbf{arial.ppm} & \textbf{bike3.ppm} \\ \midrule
Original (PPM Color) & 769 kB & 1.1 MB & 2.1 MB \\
\textbf{O Nosso Codec (.gol)} & \textbf{130 kB} & 262 kB & 423 kB \\
PNG (Max Compression) & 138 kB & \textbf{255 kB} & \textbf{420 kB} \\
FLIF (Lossless) & 124 kB & 227 kB & 374 kB \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Discussão dos Resultados}
Os resultados obtidos são excelentes e validam a qualidade do algoritmo implementado.

\begin{itemize}
    \item \textbf{Competitividade com PNG:} O nosso codec conseguiu superar o standard PNG na imagem \texttt{airplane} (130kB vs 138kB) e obteve um empate técnico na imagem \texttt{bike3} (diferença de apenas 3kB). Isto demonstra que a combinação do preditor MED com a codificação Golomb adaptativa é tão ou mais eficaz que o algoritmo DEFLATE do PNG para imagens fotográficas naturais.
    \item \textbf{Imagens Sintéticas:} Na imagem \texttt{arial} (texto/gráficos), o PNG obteve uma ligeira vantagem. Isto é esperado, pois o PNG é otimizado para detetar padrões repetitivos (como letras iguais), algo que o nosso preditor local (MED) não consegue explorar tão bem.
    \item \textbf{Proximidade ao Estado da Arte:} Em comparação com o FLIF, um dos codecs mais avançados da atualidade, o nosso codec manteve-se notavelmente próximo (e.g., 130kB vs 124kB no \texttt{airplane}).
\end{itemize}

Estes resultados comprovam que a implementação de um preditor espacial robusto (MED) é o fator crítico para o sucesso na compressão de imagem, permitindo ao codificador Golomb atingir o seu potencial máximo.


% ----------------------------------------------------------------------------------
% SECÇÃO 6: CONCLUSÕES
% ----------------------------------------------------------------------------------
\section{Conclusões}

Este trabalho laboratorial permitiu uma exploração prática e aprofundada dos conceitos de processamento de imagem e de codificação entrópica, culminando no desenvolvimento de codecs \textit{lossless} funcionais.

Na \textbf{Parte I}, adquirimos competências fundamentais na manipulação de imagens com a biblioteca OpenCV. A implementação de operações como rotação, espelhamento e ajuste de intensidade, manipulando diretamente os píxeis, serviu de base para a compreensão da estrutura de dados de uma imagem, que se revelou crucial para a Parte IV.

Na \textbf{Parte II}, foi implementada a classe \texttt{Golomb}, o motor de compressão central do projeto. A implementação de um \texttt{m} parametrizável e de estratégias de tratamento de negativos (\textit{Interleaving}) foi um exercício fundamental de codificação entrópica.

Nas \textbf{Partes III e IV}, foram implementados codecs de áudio e imagem usando a mesma arquitetura de \texttt{m} adaptativo por bloco. A comparação dos seus resultados é a conclusão mais importante deste trabalho:

\begin{itemize}
    \item O \textbf{Codec de Áudio} (Parte III) alcançou uma compressão modesta (Taxa 1.24:1).
    \item O \textbf{Codec de Imagem} (Parte IV) alcançou uma compressão excelente (Taxa 5.93:1).
\end{itemize}

Esta discrepância demonstra de forma clara que a eficácia de um codec \textit{lossless} baseado em predição não depende tanto do codificador de entropia (Golomb), mas sim da qualidade do seu modelo de predição.

O nosso codec de imagem foi altamente eficaz porque usou um preditor 2D sofisticado (MED) que gerou resíduos minúsculos. O nosso codec de áudio teve um desempenho fraco porque usou um preditor 1D muito simples (Ordem 1) que foi incapaz de modelar a natureza complexa do sinal de áudio, gerando resíduos grandes e difíceis de comprimir.

Em suma, este projeto ilustrou de forma prática a diferença fundamental entre a codificação de áudio e imagem, e provou que a compressão \textit{lossless} é um exercício de modelação estatística: quanto melhor o modelo de predição, mais "pequenos" e "previsíveis" se tornam os resíduos, e mais eficaz é a codificação entrópica final.
\end{document}