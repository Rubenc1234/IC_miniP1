\documentclass[a4paper, 11pt, portuguese]{article}

% --- PACOTES ESSENCIAIS ---
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % Codificação do ficheiro
\usepackage{babel}          % Suporte para Português
\usepackage{amsmath}        % Fórmulas matemáticas avançadas
\usepackage{amssymb}        % Símbolos matemáticos
\usepackage{graphicx}       % Inclusão de imagens
\usepackage[
    colorlinks=true,        % Links coloridos em vez de caixas
    linkcolor=blue,         % Cor dos links internos
    citecolor=blue,         % Cor das citações (se usar bib)
    urlcolor=blue           % Cor dos URLs
]{hyperref}                 % Links clicáveis (URLs, referências)
\usepackage{geometry}       % Configuração das margens
\usepackage{booktabs}       % Tabelas com melhor aspeto
\usepackage{listings}       % Blocos de código formatados
\usepackage{xcolor}         % Cores (usado nos listings)
\usepackage{float}          % Controlo mais fino da posição de floats (figuras, tabelas)
\usepackage{tcolorbox}     % Caixas coloridas (usado para destacar texto)

% --- CONFIGURAÇÕES ---

% Margens da página
\geometry{
 a4paper,
 margin=2.5cm, % Margem de 2.5cm em todos os lados
}

% Estilo para blocos de código C++
\definecolor{codegray}{rgb}{0.5,0.5,0.5} % Cor para comentários
\definecolor{codeblue}{rgb}{0,0,0.6}    % Cor para palavras-chave
\definecolor{codegreen}{rgb}{0,0.6,0}  % Cor para strings
\lstdefinestyle{cppstyle}{
    language=C++,
    basicstyle=\ttfamily\footnotesize, % Fonte monoespaçada pequena
    commentstyle=\color{codegray}\itshape, % Comentários em cinza itálico
    keywordstyle=\color{codeblue}\bfseries, % Palavras-chave a azul negrito
    stringstyle=\color{codegreen},    % Strings a verde
    numberstyle=\tiny\color{codegray}, % Números de linha pequenos e cinza
    breaklines=true,                  % Quebra de linhas longas
    frame=single,                     % Caixa à volta do código
    captionpos=b,                     % Legenda em baixo
    showstringspaces=false,           % Não mostrar espaços em strings de forma especial
    tabsize=4,                        % Tamanho da tabulação
    numbers=left,                     % Números de linha à esquerda
    stepnumber=1,                     % Numerar todas as linhas
    numbersep=5pt,                    % Espaço entre números e código
    backgroundcolor=\color{white},    % Fundo branco
    % --- Tratamento de caracteres PT ---
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
             {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
             {â}{{\^a}}1 {ê}{{\^e}}1 {ô}{{\^o}}1
             {Â}{{\^A}}1 {Ê}{{\^E}}1 {Ô}{{\^O}}1
             {ã}{{\~a}}1 {õ}{{\~o}}1
             {Ã}{{\~A}}1 {Õ}{{\~O}}1
             {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1,
}
\lstset{style=cppstyle} % Define o estilo C++ como padrão para listings

% Configuração do idioma principal do documento
\selectlanguage{portuguese}

% --- INFORMAÇÕES DO DOCUMENTO ---
\title{
    \includegraphics[width=0.4\textwidth]{imagens/ua.pdf} \\ \vspace{1.5cm}
    \textbf{Relatório do Trabalho Laboratorial nº 3} \\
    \large Informação e Codificação (2025/26)
}
\author{
    \textbf{Pedro Miguel Miranda de Melo} (114208) \\
    \textbf{Rúben Cardeal Costa} (114190) \\
    \textbf{Hugo Marques Dias} (114142) \\
    % Adicionar mais linhas conforme necessário
    \textit{Departamento de Eletrónica, Telecomunicações e Informática (DETI)} \\
    \textit{Universidade de Aveiro}
}
\date{Novembro de 2025}

% --- INÍCIO DO DOCUMENTO ---
\begin{document}

\maketitle
\thispagestyle{empty} % Remove número de página na folha de rosto

\newpage
\tableofcontents % Gera o índice automaticamente
\newpage

% ----------------------------------------------------------------------------------
% SECÇÃO 1: INTRODUÇÃO
% ----------------------------------------------------------------------------------
\section{Introdução}
O presente relatório técnico descreve o trabalho realizado no âmbito do projeto de compressão de um Grande Modelo de Linguagem (LLM). O objetivo central passa por desenvolver uma estratégia de compressão otimizada e eficiente para o ficheiro \texttt{model.safetensors} ($\sim 1\text{ GB}$) que contém os parâmetros de um LLM.\colorbox{yellow}{Continuar...}


% ----------------------------------------------------------------------------------
% SECÇÃO 2: ANÁLISE E CARACTERIZAÇÃO DA FONTE
% ----------------------------------------------------------------------------------
\section{Análise e Caracterização da Fonte}

Para desenhar um codec eficiente, é imperativo compreender a natureza estatística da fonte de informação. Esta secção detalha a análise teórica e experimental realizada sobre o ficheiro \texttt{model.safetensors}.

\subsection{Análise Estrutural (Formato de Dados)}
A inspeção do cabeçalho do ficheiro revelou que os dados estão armazenados no formato \textbf{BF16} (\textit{Brain Floating Point 16}). Ao contrário de inteiros de 16 bits, onde a distribuição de bits tende a ser uniforme em dados aleatórios, o BF16 possui uma semântica específica composta por:
\begin{itemize}
    \item \textbf{1 bit de Sinal ($S$)} e \textbf{8 bits de Expoente ($E$)}: Ocupam maioritariamente o byte mais significativo (MSB).
    \item \textbf{7 bits de Mantissa ($M$)}: Ocupam o byte menos significativo (LSB).
\end{itemize}

Esta estrutura sugere a existência de correlações não-lineares e localizadas que uma análise puramente sequencial (byte-a-byte) poderá não capturar eficazmente.

\subsection{Limites Teóricos e Análise Global}
O limite teórico fundamental para a compressão sem perdas é dado pela \textbf{Entropia de Shannon}. Considerando o ficheiro como uma fonte de memória nula $X$ que gera símbolos $x \in \{0, \dots, 255\}$, a entropia de ordem-0 é definida por:

\begin{equation}
    H(X) = - \sum_{i=0}^{255} P(x_i) \log_2 P(x_i) \quad \text{[bits/símbolo]}
    \label{eq:shannon}
\end{equation}

Experimentalmente, ao aplicar a Equação \ref{eq:shannon} à totalidade do \textit{payload} binário, obteve-se:
\begin{center}
    \textbf{$H(X) \approx 6.22$ bits/byte}
\end{center}

Este valor indica que, ignorando qualquer dependência entre bytes, a compressão máxima teórica seria de apenas $\sim 22\%$. Para investigar dependências sequenciais, calculou-se a \textbf{Entropia Condicional} de primeira ordem, que mede a incerteza de um símbolo $X_n$ dado o conhecimento do anterior $X_{n-1}$:

\begin{equation}
    H(X|Y) = - \sum_{y \in \mathcal{X}} P(y) \sum_{x \in \mathcal{X}} P(x|y) \log_2 P(x|y)
    \label{eq:conditional}
\end{equation}

O resultado experimental obtido foi:
\begin{center}
    \textbf{$H(X_n | X_{n-1}) \approx 5.36$ bits/byte}
\end{center}

Embora $H(X|Y) < H(X)$, confirmando a existência de correlação inter-simbólica (teorema do condicionamento reduz a entropia), o valor $5.36$ permanece elevado. A nossa hipótese é que a natureza intercalada dos dados BF16 (MSB estruturado seguido de LSB ruidoso) "mascara"\ a verdadeira correlação entre os pesos adjacentes.

\subsection{Análise Estrutural Diferenciada (\textit{Byte-Splitting})}
Para validar a hipótese de que a entropia está concentrada no byte da mantissa, procedeu-se à separação do fluxo de dados em dois canais distintos: \textit{Stream MSB} (bytes ímpares) e \textit{Stream LSB} (bytes pares).

As entropias de ordem-0 foram recalculadas individualmente para cada canal:

\begin{table}[H]
    \centering
    \caption{Comparação de Entropia por Canal (Split)}
    \label{tab:split_results}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Canal} & \textbf{Conteúdo} & \textbf{Entropia Medida ($H$)} & \textbf{Característica} \\
        \midrule
        \textbf{MSB} & Expoente/Sinal & \textbf{2.71 bits/byte} & Altamente Estruturado \\
        \textbf{LSB} & Mantissa & \textbf{7.96 bits/byte} & Ruído Quase Uniforme \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection*{Evidência Visual}
Os histogramas de frequência (Figuras \ref{fig:hist_msb} e \ref{fig:hist_lsb}) corroboram os valores numéricos. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/histogram_msb.png} % Certifica-te que a imagem está nesta pasta
    \caption{Histograma do Byte Mais Significativo (MSB). Nota-se uma distribuição Laplaciana acentuada, típica de pesos de redes neuronais normalizados, justificando o valor baixo de $H \approx 2.71$.}
    \label{fig:hist_msb}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{imagens/histogram_lsb.png}
    \caption{Histograma do Byte Menos Significativo (LSB). A distribuição aproxima-se da uniforme (plana), o que explica a entropia de $H \approx 7.96$, muito próxima do máximo teórico de 8 bits.}
    \label{fig:hist_lsb}
\end{figure}

\subsection{Síntese e Estratégia Adotada}
A média das entropias separadas é $(2.71 + 7.96)/2 \approx 5.34$, um valor virtualmente idêntico à Entropia Condicional global ($5.36$). Isto leva-nos a concluir que a "memória"\ da fonte detetada na análise global era, na verdade, a estrutura interna do formato BF16 e não apenas correlação sequencial.

\begin{tcolorbox}[colback=yellow!10!white,colframe=yellow!50!black,title=Nota]
Com base nestes dados teóricos e experimentais, a estratégia de compressão será:
\begin{enumerate}
    \item \textbf{Pré-processamento (Split):} Separar os fluxos para isolar o ruído da estrutura.
    
    \item \textbf{Canal LSB:} Dado que $H \approx 8$, não justifica custo computacional elevado. Será armazenado com compressão mínima ou nula.
    \item \textbf{Canal MSB:} Dado que $H \approx 2.71$, este canal é o candidato ideal para \textbf{Codificação Preditiva} (Delta) seguida de \textbf{Codificação Entrópica} (Huffman ou Aritmética), visando reduzir a entropia residual para valores próximos de 2 bits/byte.
    
\end{enumerate}
\end{tcolorbox}

% ----------------------------------------------------------------------------------
% SECÇÃO 3: IMPLEMENTAÇÃO DO CODEC (CANAL MSB)
% ----------------------------------------------------------------------------------
\section{Implementação e Otimização do Canal MSB}

Com base na análise preliminar, o canal MSB (Byte Mais Significativo) apresentava uma entropia de base de $2.70$ bits/byte, tornando-se o foco principal para ganhos de compressão. Esta secção descreve o processo iterativo de otimização, desde as tentativas de modelação preditiva até à seleção do codificador de entropia final.

\subsection{Avaliação de Técnicas de Transformação Preditiva}
A literatura de compressão de dados (e.g., JPEG Lossless, Audio Coding) sugere frequentemente o uso de codificação preditiva para reduzir a variância dos resíduos em sinais correlacionados. Testaram-se duas abordagens para explorar a correlação sequencial entre os pesos do modelo.

\subsubsection{Abordagem 1: Preditor Linear Aritmético (Delta)}
A primeira tentativa utilizou um preditor de primeira ordem clássico, onde o resíduo $r_n$ é calculado pela diferença aritmética entre o byte atual $x_n$ e o anterior $x_{n-1}$:
\begin{equation}
    r_n = (x_n - x_{n-1}) \mod 256
\end{equation}
\textbf{Resultado:} Contrariamente ao esperado, a aplicação deste preditor \textbf{aumentou} a entropia do canal MSB de $2.70$ para $3.28$ bits/byte (um ganho negativo de $-0.58$ bits).

\textbf{Análise de Falha:} A inspeção dos dados revelou que este comportamento se deve ao formato \texttt{BF16}. O bit mais significativo do MSB corresponde ao \textit{Sinal}. Quando os pesos da rede neuronal oscilam entre valores pequenos positivos e negativos (comum em LLMs), o bit de sinal alterna (e.g., de $0$ para $1$), o que a subtração aritmética interpreta como um "salto"\ numérico de grande magnitude (e.g., $+128$), dispersando o histograma dos resíduos.

\subsubsection{Abordagem 2: Preditor Lógico (XOR)}
Para mitigar o problema do bit de sinal, implementou-se um preditor baseado na operação exclusiva-ou (XOR), comum em compressores de ponto flutuante como o FPC, para capturar semelhanças de padrões de bits independentemente do valor aritmético:
\begin{equation}
    r_n = x_n \oplus x_{n-1}
\end{equation}
\textbf{Resultado:} Embora tenha apresentado um desempenho superior ao preditor aritmético, a entropia resultante foi de $3.11$ bits/byte, ainda superior à entropia original de $2.70$ bits.

\subsubsection{Decisão de Engenharia}
Concluiu-se que a baixa entropia do canal MSB ($2.70$ bits) não advém da correlação sequencial imediata ($x_n \approx x_{n-1}$), mas sim da distribuição global dos expoentes (distribuição bimodal estática). Qualquer tentativa de transformação preditiva simples tende a destruir esta estrutura estatística favorável.
Consequentemente, optou-se por \textbf{não aplicar transformações} e codificar diretamente os valores brutos do canal MSB.

\subsection{Codificação de Entropia: Huffman vs. Aritmética}
Após definir que os dados seriam codificados sem transformação prévia, comparou-se o desempenho de dois algoritmos de entropia para o passo final de compressão.

\begin{table}[htbp]
    \centering
    \caption{Comparação de Desempenho no Ficheiro Completo (Canal MSB)}
    \label{tab:entropy_bench}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Algoritmo} & \textbf{Tamanho Final} & \textbf{Tempo Total} & \textbf{Rácio Efetivo} \\
        \midrule
        Huffman (Estático) & 633.04 MB & \textbf{13.98 s} & 1.58:1 \\
        Aritmético (Estático) & \textbf{631.00 MB} & 19.07 s & 1.59:1 \\
        \bottomrule
    \end{tabular}
\end{table}

A Codificação Aritmética permitiu uma redução adicional de $\approx 2$ MB. Teoricamente, isto deve-se à sua capacidade de alocar um número fracionário de bits por símbolo, aproximando-se do limite da entropia ($2.70$), enquanto o Huffman é penalizado pela restrição de usar números inteiros de bits. Contudo, este ganho marginal ($0.3\%$) implicou um custo computacional de $36\%$ no tempo de execução.

\subsection{Definição dos Modos de Operação}
Para cumprir os requisitos de projeto que exigem diferentes pontos de operação (compromisso tempo/compressão), definiram-se dois modos no compressor final:

\begin{itemize}
    \item \textbf{Modo \textit{Fast}:} Utiliza o algoritmo de \textbf{Huffman}. Prioriza a velocidade de processamento, ideal para cenários de inferência em tempo real ou carregamento rápido de modelos.
    \item \textbf{Modo \textit{Best}:} Utiliza a \textbf{Codificação Aritmética}. Prioriza a minimização absoluta do espaço em disco, ideal para arquivo ou distribuição em redes com largura de banda limitada.
\end{itemize}
% ----------------------------------------------------------------------------------
% SECÇÃO 6: CONCLUSÕES
% ----------------------------------------------------------------------------------
\section{Conclusões}


\end{document}
